@page "/{Banned?}"
@using community.Data
@using community.Dtos
@using community.Services
@using System.Threading.Tasks
@inject GameListService GameListService
@inject ChallengeService ChallengeService
@inject ChallengeSessionState ChallengeSessionState
@inject UserService UserService
@inject NavigationManager NavigationManager
@using community.Utils
@inject IStringLocalizer<Home> Loc

<div class="row">
    <div class="col">
        <h1 class="open-title"><b>Open Video Game Data</b></h1>
        <p>@Loc["Subtitle"]</p>
    </div>
</div>

<div class="row">
    <div style="padding: 0.5em;">
        @if (pinnedLists == null)
        {
            <p><em>@Loc["Loading"]...</em></p>
        }
        else
        {
            if (Banned == "banned")
            {
                <h1><b>@Loc["Banned"]</b></h1>
            }
            @if (microChallenge is not null && !challengeDismissed)
            {
                <div class="micro-challenge-container">
                    <MicroChallengeCard Challenge="@microChallenge"
                                        Title="@GetChallengeTitle(microChallenge)"
                                        Subtitle="@Loc["MicroChallengeSubtitle"]"
                                        LinkText="@Loc["MicroChallengeLinkLabel"]"
                                        AcceptText="@Loc["MicroChallengeAccept"]"
                                        SkipText="@Loc["MicroChallengeSkip"]"
                                        CompleteText="@Loc["MicroChallengeComplete"]"
                                        SourcesLabel="@Loc["MicroChallengeSourcesLabel"]"
                                        PercentageLabel="@Loc["MicroChallengePercentageLabel"]"
                                        AcceptedLabel="@Loc["MicroChallengeAcceptedLabel"]"
                                        CompletedLabel="@Loc["MicroChallengeCompletedLabel"]"
                                        AllowInteractions="@allowChallengeInteractions"
                                        InteractionHint="@(!allowChallengeInteractions ? Loc["MicroChallengeGuestHint"] : string.Empty)"
                                        IsBusy="@challengeBusy"
                                        AcceptClicked="EventCallback.Factory.Create(this, OnChallengeAcceptedAsync)"
                                        SkipClicked="EventCallback.Factory.Create(this, OnChallengeSkipped)"
                                        CompleteClicked="EventCallback.Factory.Create(this, OnChallengeCompletedAsync)" />
                </div>
            }
            else if (challengeDismissed)
            {
                <div class="micro-challenge-container">
                    <div class="micro-challenge-dismissed">@Loc["MicroChallengeDismissedMessage"]</div>
                </div>
            }
            else if (microChallenge is null && showMicroChallengeFallback)
            {
                <div class="micro-challenge-container">
                    <div class="micro-challenge-dismissed">@Loc["MicroChallengeFallbackText"]</div>
                </div>
            }
            <h2>@Loc["TrendingTitle"]</h2>
            <p class="open-sub-title">@Loc["TrendingSubtitle"]</p>
            <hr style="margin-bottom: 10px; margin-top: 0; position: relative; z-index: -999;"/>
            <GameLists FinalGameList="@pinnedLists" IsUserList="false"></GameLists>

            <h2 class="mt-5">@Loc["UserActivityTitle"]</h2>
            <p class="open-sub-title">@Loc["UserActivitySubtitle"]</p>
            <hr style="margin-bottom: 10px; margin-top: 0; position: relative; z-index: -999;"/>
            @foreach (var userActivity in userActivityList)
            {
                @if (userActivity.Activity == ActivityType.GameList)
                {
                    @if(userActivity.GameList is not null && userActivity.User is not null)
                    {
                        <div class="user-perfil-of-user-activity">
                            <div class="user-perfil-of-user-activity-picture">
                                <PixelEditor canEdit="@false" size="1" matrix="@userActivity.User.GetUserPicture()" userNickname="@userActivity.User.FullName" showLoading="true"/>
                            </div>
                            <div class="user-perfil-of-user-activity-name">
                                <div><a href="@userActivity.UserProfileUrl">@userActivity.User.FullName</a> @Loc["UserActivityDescriptionList"]:</div>
                                <div>"<a class="source-tag-a" href="@userActivity.GameListUrl">@userActivity.GameList.FinalGameList?.GetFullName()</a>" @(userActivity.DateAdded.ToNaturalLanguage<Home>(loc: Loc))</div>
                            </div>
                        </div>
                    }
                }
                @if (userActivity.Activity == ActivityType.Tracker)
                {
                    @if(userActivity.MostRecentTracker is not null && userActivity.User is not null)
                    {
                        <div class="user-perfil-of-user-activity">
                            <div class="user-perfil-of-user-activity-picture">
                                <PixelEditor canEdit="@false" size="1" matrix="@userActivity.User.GetUserPicture()" userNickname="@userActivity.User.FullName" showLoading="true"/>
                            </div>
                            <div class="user-perfil-of-user-activity-name">
                                <div><a href="@userActivity.UserProfileUrl">@userActivity.User.FullName</a> @Loc["UserActivityDescriptionTracker"]:</div>
                                <div>@Loc["UserActivityDescriptionTracker1"] @userActivity.ItemsTracked <a href="@(userActivity.UserProfileUrl + $"/trackers?trackStatus={(int)userActivity.MostRecentTracker.Status}")">@Loc["UserActivityDescriptionTracker2"]</a> @Loc["UserActivityDescriptionTimeTracker"] @(userActivity.DateAdded.ToNaturalLanguage<Home>(false, Loc))</div>
                            </div>
                        </div>
                    }
                }
            }

            <button class="btn btn-primary mt-3" @onclick="() => GotoCreateList()"><span class="oi oi-plus" aria-hidden="true"></span> @Loc["CreateYourList"]</button>

            <h2 class="mt-5">@Loc["AllGameListsTitle"]</h2>
            <p class="open-sub-title">@Loc["AllGameListsSubtitle"]</p>
            <hr style="margin-bottom: 10px; margin-top: 0; position: relative; z-index: -999;"/>
            <InputText disabled="@searching" class="form-control mb-3" @bind-Value="searchedList" @onblur="SearchList" @onkeyup="@PressedKey"/>

            @foreach (var tag in allTags)
            {
                <div class="tag">
                    @if (this.tagsToFilter.Contains(tag)) {
                        <button disabled="@searching" style="width: 120px;" class="btn btn-secondary" @onclick="() => FilterBy(tag)">@tag.FirstCharToUpper()</button>
                    } else {
                        <button disabled="@searching" style="width: 120px;" class="btn btn-primary" @onclick="() => FilterBy(tag)">@tag.FirstCharToUpper()</button>
                    }
                </div>
            }

            <ListsCategories Filters="@Filters"/>
        }
    </div>
</div>
<style>
    .open-sub-title {
        color: rgb(192, 192, 192);
        font-size: 0.9em;
    }

    .open-title {
        font-size: 2em;
    }

    .user-perfil-of-user-activity-picture {
        display: inline-block;
        margin-right: 0.5em;
    }

    .user-perfil-of-user-activity-name {
        display: inline-block;
        padding-bottom: 0.5em;
    }


    .tag {
        display: inline-block;
        padding: 0.1em;
    }
</style>
@code {

    [ParameterAttribute]
    public string? Banned { get; set; }
    private List<FinalGameList>? pinnedLists = new List<FinalGameList>();
    private List<UserActivityData> userActivityList = new List<UserActivityData>();
    public FilterListsCategory Filters { get; set; } = null;
    private int totalNumberOfGameLists = 0;
    private int totalNUmberOfUsers = 0;
    private string searchedList = "";
    private bool searching = false;
    private List<string> tagsToFilter = new List<string>();
    private List<string> allTags = new List<string>();
    private MicroChallengeDto? microChallenge;
    private bool allowChallengeInteractions;
    private bool challengeBusy;
    private bool challengeDismissed;
    private bool showMicroChallengeFallback;
    private long loggedUserId;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        var userIsLogged = UserService.IsLogged();
        if (userIsLogged)
        {
            var user = UserService.GetLoggedUser();
            if (user is not null)
            {
                loggedUserId = user.Id;
            }
        }

        allowChallengeInteractions = loggedUserId > 0;
        var contextUserId = allowChallengeInteractions ? loggedUserId : 0;

        this.pinnedLists = GameListService.GetAllPinnedLists(userId: contextUserId);
        this.userActivityList = GameListService.GetUserActivity();
        this.allTags = FilterListsCategory.GetTagsList();

        microChallenge = ChallengeService.BuildChallengeFromLists(this.pinnedLists, contextUserId);
        if (microChallenge is not null)
        {
            var storedChallenge = ChallengeSessionState.Get(microChallenge.ChallengeId);
            if (storedChallenge is not null)
            {
                microChallenge = storedChallenge;
            }
            else
            {
                ChallengeSessionState.Store(microChallenge);
            }

            showMicroChallengeFallback = false;
        }
        else
        {
            showMicroChallengeFallback = true;
        }
    }

    private string GetUserPerfilUrl(User? user)
    {
        if (user is not null) {
            return $"/users/{user.Nickname}";
        }

        return "";
    }

    private string GetGameListUrl(long gameListId) {
        return $"/view-list/{gameListId}";
    }

    private string GetChallengeTitle(MicroChallengeDto challenge)
    {
        if (challenge is null)
            return string.Empty;

        var listName = challenge.SourceYear.HasValue && challenge.SourceYear.Value > 0
            ? $"{challenge.SourceTitle} {challenge.SourceYear}"
            : challenge.SourceTitle;

        return string.Format(Loc["MicroChallengeTitle"].Value, listName);
    }

    private void ViewList(string slug)
    {
        NavigationManager.NavigateTo($"/list/{slug}");
    }

    private async Task OnChallengeAcceptedAsync()
    {
        if (!allowChallengeInteractions || microChallenge is null || challengeBusy)
            return;

        challengeBusy = true;
        try
        {
            await ChallengeService.ApplyTrackerStatusAsync(microChallenge, loggedUserId, TrackStatus.ToPlay);
            foreach (var game in microChallenge.SuggestedGames)
            {
                if (game.TrackStatus == TrackStatus.None)
                {
                    game.TrackStatus = TrackStatus.ToPlay;
                }
            }

            microChallenge = microChallenge.Accept();
            ChallengeSessionState.Store(microChallenge);
        }
        finally
        {
            challengeBusy = false;
        }
    }

    private async Task OnChallengeCompletedAsync()
    {
        if (!allowChallengeInteractions || microChallenge is null || challengeBusy)
            return;

        challengeBusy = true;
        try
        {
            await ChallengeService.ApplyTrackerStatusAsync(microChallenge, loggedUserId, TrackStatus.Played);
            foreach (var game in microChallenge.SuggestedGames)
            {
                if (game.TrackStatus != TrackStatus.Beaten)
                {
                    game.TrackStatus = TrackStatus.Played;
                }
            }

            microChallenge = microChallenge.Complete();
            ChallengeSessionState.Store(microChallenge);
        }
        finally
        {
            challengeBusy = false;
        }
    }

    private void OnChallengeSkipped()
    {
        if (microChallenge is not null)
        {
            ChallengeSessionState.Clear(microChallenge.ChallengeId);
        }

        microChallenge = null;
        challengeDismissed = true;
        showMicroChallengeFallback = false;
    }

    private void FilterBy(string tag = Tags.All) {
        if (tag == Tags.All) {
            this.tagsToFilter = new List<string> { Tags.All };
        } else {
            if (this.tagsToFilter.Contains(Tags.All)) {
                this.tagsToFilter.Remove(Tags.All);
            }

            if (this.tagsToFilter.Contains(tag)) {
                this.tagsToFilter.Remove(tag);
            } else {
                this.tagsToFilter.Add(tag);
            }
        }

        if (!this.tagsToFilter.Any()) {
            this.tagsToFilter.Add(Tags.All);
        }

        this.GetAllLists();
    }

    private void GotoCreateList() {
        NavigationManager.NavigateTo("/users/lists/new");
    }

    private void GetAllLists(int page = 1, string searchedListText = "")
    {
        Filters = new FilterListsCategory(page, 6, 5, this.tagsToFilter, searchedListText);
    }

    private void SearchList()
    {
        GetAllLists(1, searchedList);
    }

    private void PressedKey(KeyboardEventArgs e)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
            GetAllLists(1, searchedList);
    }
}
